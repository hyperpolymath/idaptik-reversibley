= Idaptik Reversible VM ğŸ”„

*A reversible computation virtual machine implemented in ReScript + Deno*

[![License: MIT](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![License: Palimpsest](https://img.shields.io/badge/license-Palimpsest%20v0.8-purple.svg)](LICENSE-PALIMPSEST.txt)
[![Language](https://img.shields.io/badge/language-ReScript-E6484F.svg)](https://rescript-lang.org/)
[![Runtime](https://img.shields.io/badge/runtime-Deno-000000.svg)](https://deno.land/)
[![Rhodium Standard](https://img.shields.io/badge/standard-Rhodium-gold.svg)](https://rhodium.dev/)

---

== ğŸ¯ What is Idaptik?

Idaptik is a *reversible computation* virtual machine where every operation can be *perfectly undone*. It's designed for:

- ğŸ§© *Logic puzzles* - Solve puzzles by forward and backward execution
- â†©ï¸ *Undo systems* - Build robust undo/redo functionality
- ğŸ”¬ *Reversible algorithms* - Explore reversible computing concepts
- ğŸ“ *Education* - Learn about time-reversible computation

=== Key Concept

```
Forward:  x=5  â†’  [ADD x 3]  â†’  x=8
Reverse:  x=8  â†  [UNDO]     â†  x=5  (perfectly restored!)
```

Every instruction has an *inverse* that reverses its effect without information loss.

---

== âœ¨ Features

- âœ… *5 Core Instructions:* ADD, SUB, SWAP, NEGATE, NOOP
- âœ… *Perfect Reversibility:* Every operation is perfectly undoable
- âœ… *Type Safety:* ReScript's sound type system prevents errors
- âœ… *Zero Dependencies:* No npm, no node_modules, just Deno + ReScript
- âœ… *Puzzle System:* JSON-based puzzle definitions
- âœ… *CLI Interface:* Full command-line interface with demo and tests
- âœ… *Comprehensive Build System:* 40+ Just recipes for all tasks

---

== ğŸš€ Quick Start

=== Prerequisites

```bash
= Install Deno (JavaScript runtime)
curl -fsSL https://deno.land/install.sh | sh

= Install ReScript (compiler)
npm install -g rescript

= Install Just (task runner)
cargo install just   # OR: sudo dnf install just
```

=== Build & Run

```bash
= 1. Check dependencies
just doctor

= 2. Build the project
just build

= 3. Run demonstration
just demo
```

*Expected output:*
```
[INFO] Starting reversible VM demo...
[INFO] Initial state: x=5, y=3, z=0
[INFO] Executing: ADD x y (x = x + y)
Current State: { x: 8, y: 3, z: 0 }
[INFO] Executing: SWAP x z
Current State: { x: 0, y: 3, z: 8 }
[INFO] Executing: NEGATE y
Current State: { x: 0, y: -3, z: 8 }

[INFO] Now reversing operations...
[INFO] Undoing NEGATE y
Current State: { x: 0, y: 3, z: 8 }
[INFO] Undoing SWAP x z
Current State: { x: 8, y: 3, z: 0 }
[INFO] Undoing ADD x y
Current State: { x: 5, y: 3, z: 0 }
[SUCCESS] Demo complete! Notice how undo perfectly reversed all operations.
```

---

== ğŸ“š Documentation

- *[MIGRATION-GUIDE.md](MIGRATION-GUIDE.md)* - Complete guide from TypeScript to ReScript
- *[CONVERSION-SUMMARY.md](CONVERSION-SUMMARY.md)* - Detailed conversion report
- *[justfile](justfile)* - All available commands (run `just help`)

---

== ğŸ› ï¸ Usage

=== CLI Commands

```bash
= Show help
deno run --allow-read src/CLI.res.js help

= Run demonstration
deno run --allow-read src/CLI.res.js demo

= Run tests
deno run --allow-read src/CLI.res.js test

= Run puzzle (TODO: implement)
deno run --allow-read src/CLI.res.js run vault_7
```

=== Build System

```bash
= Core commands
just build          # Compile ReScript â†’ JavaScript
just clean          # Remove artifacts
just watch          # Auto-rebuild on changes

= Development
just dev            # Development mode
just run            # Run CLI
just demo           # Run demo
just test           # Run tests

= Quality
just format         # Format code
just lint           # Lint code
just verify         # Full verification (build + test + lint)
just ci             # Complete CI pipeline

= Puzzles
just list-puzzles       # List all puzzles
just puzzle <name>      # Run specific puzzle
just create-puzzle <n>  # Create new puzzle

= Information
just status         # Project status
just stats          # Code statistics
just help           # Detailed help
```

*Aliases:* `b` (build), `c` (clean), `r` (run), `d` (demo), `t` (test), `w` (watch)

---

== ğŸ§© Instruction Set

| Instruction | Syntax | Operation | Inverse | Example |
|-------------|--------|-----------|---------|---------|
| *ADD* | `ADD a b` | `a = a + b` | `a = a - b` | `ADD x y` â†’ x=15 (if x=10, y=5) |
| *SUB* | `SUB a b` | `a = a - b` | `a = a + b` | `SUB x y` â†’ x=5 (if x=10, y=5) |
| *SWAP* | `SWAP a b` | swap values | swap again | `SWAP x y` â†’ x=5, y=10 (if x=10, y=5) |
| *NEGATE* | `NEGATE a` | `a = -a` | negate again | `NEGATE x` â†’ x=-10 (if x=10) |
| *NOOP* | `NOOP` | (nothing) | (nothing) | `NOOP` â†’ no change |

All instructions are *perfectly reversible* - running the inverse restores the exact previous state.

---

== ğŸ“ Project Structure

```
idaptik-reversible/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ Instruction.res      # Instruction interface
â”‚   â”‚   â”œâ”€â”€ State.res            # State management
â”‚   â”‚   â”œâ”€â”€ VM.res               # Virtual machine
â”‚   â”‚   â””â”€â”€ instructions/
â”‚   â”‚       â”œâ”€â”€ Add.res
â”‚   â”‚       â”œâ”€â”€ Sub.res
â”‚   â”‚       â”œâ”€â”€ Swap.res
â”‚   â”‚       â”œâ”€â”€ Negate.res
â”‚   â”‚       â””â”€â”€ Noop.res
â”‚   â””â”€â”€ CLI.res                  # Command-line interface
â”œâ”€â”€ data/
â”‚   â””â”€â”€ puzzles/
â”‚       â”œâ”€â”€ vault_7.json
â”‚       â””â”€â”€ vault_defuse.json
â”œâ”€â”€ rescript.json                # ReScript config
â”œâ”€â”€ deno.json                    # Deno config
â”œâ”€â”€ justfile                     # Build system (600+ lines!)
â”œâ”€â”€ .gitignore                   # Updated for ReScript + Deno
â”œâ”€â”€ MIGRATION-GUIDE.md          # Migration documentation
â”œâ”€â”€ CONVERSION-SUMMARY.md       # Conversion report
â””â”€â”€ README-NEW.md               # This file
```

---

== ğŸ“ Examples

=== Basic VM Usage

```rescript
// Create initial state
let state = State.createState(~variables=["x", "y"], ~initialValue=0)
Js.Dict.set(state, "x", 10)
Js.Dict.set(state, "y", 5)

// Create VM
let vm = VM.make(state)

// Execute forward
VM.run(vm, Add.make("x", "y"))  // x = 15
VM.run(vm, Swap.make("x", "y"))  // x = 5, y = 15

// Execute backward (undo)
VM.undo(vm)  // Undo SWAP: x = 15, y = 5
VM.undo(vm)  // Undo ADD: x = 10, y = 5
```

=== Creating a Puzzle

```json
{
  "name": "My Puzzle",
  "description": "Get x to 100",
  "initialState": {
    "x": 0,
    "y": 10,
    "z": 5
  },
  "goalState": {
    "x": 100,
    "y": 10,
    "z": 5
  },
  "maxMoves": 20,
  "instructions": [
    {"type": "ADD", "args": ["x", "y"]},
    {"type": "SUB", "args": ["x", "z"]},
    {"type": "SWAP", "args": ["x", "z"]}
  ]
}
```

Save as `data/puzzles/my_puzzle.json`, then run:

```bash
just puzzle my_puzzle
```

---

== ğŸ”§ Technology Stack

=== Core Technologies

- *[ReScript](https://rescript-lang.org/)* - Sound type system, compiles to JavaScript
- *[Deno](https://deno.land/)* - Modern, secure JavaScript runtime
- *[Just](https://github.com/casey/just)* - Powerful command runner

=== Why This Stack?

| Aspect | Benefit |
|--------|---------|
| *No Dependencies* | Zero npm packages, no node_modules (saves ~100MB) |
| *Type Safety* | ReScript's sound types catch errors at compile time |
| *Security* | Deno's explicit permissions (`--allow-read`, etc.) |
| *Performance* | Fast compilation, optimized JavaScript output |
| *Developer Experience* | Excellent error messages, fast feedback loop |

---

== ğŸ§ª Testing

```bash
= Run all tests
just test

= Expected output:
[INFO] Running instruction tests...
[SUCCESS] âœ“ ADD test passed
[SUCCESS] âœ“ ADD invert test passed
[SUCCESS] âœ“ SWAP test passed
[SUCCESS] âœ“ SWAP invert test passed
[SUCCESS] All tests passed!
```

Tests verify:
- âœ“ Forward execution correctness
- âœ“ Inverse execution correctness
- âœ“ Perfect reversibility (forward then inverse = identity)

---

== ğŸ¤ Contributing

This is a demonstration project showing ReScript + Deno integration. To extend it:

1. *Add new instructions:* Create `src/core/instructions/MyInstruction.res`
2. *Add new puzzles:* Create JSON files in `data/puzzles/`
3. *Extend CLI:* Modify `src/CLI.res`

=== Development Workflow

```bash
= Terminal 1: Watch mode
just watch

= Terminal 2: Run tests after each change
while true; do just test; sleep 2; done

= Terminal 3: Try changes
just demo
```

---

== ğŸ¯ Roadmap

=== Phase 1: Core (âœ… Complete)
- [x] ReScript core modules
- [x] Basic instructions (ADD, SUB, SWAP, NEGATE, NOOP)
- [x] CLI interface
- [x] Test suite
- [x] Comprehensive build system

=== Phase 2: Enhanced Features (ğŸ“ TODO)
- [ ] Implement puzzle loader
- [ ] Add more complex instructions (XOR, ROL, ROR, etc.)
- [ ] Conditional execution
- [ ] Loop constructs (reversible loops!)
- [ ] Visualization mode

=== Phase 3: Advanced (ğŸ”® Future)
- [ ] Web interface (Deno Fresh framework)
- [ ] Visual debugger with step-through
- [ ] Puzzle editor
- [ ] Performance benchmarks
- [ ] Optimization passes

---

== ğŸ“– Reversible Computing Background

=== Theory

Reversible computing is based on the principle that computation can be performed without losing information. Key concepts:

- *Landauer's Principle:* Irreversible operations dissipate energy
- *Bennett's Reversible Turing Machine:* Computation can be reversible
- *Janus Language:* First practical reversible programming language

=== Applications

- *Quantum Computing:* Quantum gates are inherently reversible
- *Low-Power Computing:* Reversible circuits use less energy
- *Debugging:* Perfect undo for debugging complex systems
- *Cryptography:* Reversible operations in encryption

=== Learn More

- [Reversible Computing - Wikipedia](https://en.wikipedia.org/wiki/Reversible_computing)
- [Landauer's Principle](https://en.wikipedia.org/wiki/Landauer%27s_principle)
- [Janus Language](https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language))

---

== ğŸ“„ License

*Dual Licensed: MIT OR Palimpsest License v0.8*

This project is dual-licensed - you may use it under either license at your choice:

=== Primary License: MIT

Permissive, widely compatible open source license.
- âœ… Commercial use allowed
- âœ… Modification allowed
- âœ… Distribution allowed
- âœ… Private use allowed

See [LICENSE](LICENSE) for full MIT License text.

=== Secondary License: Palimpsest v0.8

Audit-grade, consent-aware, provenance-rich license for responsible software development.
- âœ… Same freedoms as MIT
- â• Provenance tracking encouraged
- â• Ethical use guidelines
- â• Audit trail support

See [LICENSE-PALIMPSEST.txt](LICENSE-PALIMPSEST.txt) for full Palimpsest License text.

=== Legacy: AGPL-3.0

The original v1.0.0 TypeScript implementation was AGPL-3.0. For compatibility, the AGPL-3.0 text is preserved in [license.txt](license.txt).

*Note:* v2.0.0 (ReScript/Deno) uses MIT OR Palimpsest - much more permissive!

=== Which License Should I Use?

*Choose MIT if:*
- You want maximum compatibility
- You need a widely-recognized OSS license
- You prefer simple, battle-tested terms

*Choose Palimpsest if:*
- You value provenance and audit trails
- You want ethical use guidelines
- You're building consent-aware systems
- You want to support the Rhodium Standard

*In practice:* Both licenses permit the same uses. Pick whichever fits your needs!

=== Authors & Contributors

- *Joshua & Jonathan Jewell* - Original design and implementation
- *ReScript/Deno Conversion:* 2025-11-21

See [CONTRIBUTING.md](CONTRIBUTING.md) for how to contribute.

---

== ğŸ™ Acknowledgments

- *ReScript Team* - Excellent type system and compiler
- *Deno Team* - Modern, secure JavaScript runtime
- *Just Maintainers* - Powerful command runner
- *Reversible Computing Community* - Pioneering research

---

== ğŸ“ Support

- *Documentation:* See `MIGRATION-GUIDE.md` and `CONVERSION-SUMMARY.md`
- *Commands:* Run `just help` for all available commands
- *Issues:* Report at the project repository

---

*Built with â¤ï¸ using ReScript + Deno*

*Demonstrating that modern web technologies can be simple, safe, and elegant.*
